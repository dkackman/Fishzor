@implements IDisposable
@using System.Timers
@using Microsoft.JSInterop
@using System.Diagnostics
@using Fishzor.Client.Components
@using global::Fishzor.Client.Components
@inject IJSRuntime JSRuntime

<div @ref="fishElement"
    style="@($"position: absolute; left: {Position.Left}px; top: {Position.Top}px; transform: scale({Scale});")">
    <img src="@FishImagePath" alt="@Color" />
</div>

@code {
    public FishColor Color { get; set; } = FishColor.Orange;
    public string Scale { get; set; } = "100.0";
    public string FrameDuration { get; set; } = "100"; // used to find the correct file name
    public Direction Direction => FishVelocity.dx > 0 ? Direction.Right : Direction.Left;
    public string FishImagePath => $"fish/{Color}/{Direction}-{FrameDuration}.png";

    private ElementReference fishElement;
    private readonly Timer _animationTimer = new(50);
    private Point Position = new();
    private Velocity FishVelocity = new();

    private static readonly Random _random = new Random();

    private const int HEIGHT = 84;
    private const int WIDTH = 144;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // place the new fish at a random point within the tank
            var tankRect = await JSRuntime.InvokeAsync<ClientRect>("getTankRect");
            var left = (tankRect.Width - 100.0) * _random.NextDouble();
            var top = (tankRect.Height - 100.0) * _random.NextDouble();

            Position = new Point(left, top);
            await InvokeAsync(StateHasChanged); // Ensure component re-renders on UI thread

            // now turn on the timer that drives the animation
            _animationTimer.AutoReset = true;
            _animationTimer.Enabled = true;
        }
    }

    protected override void OnInitialized()
    {
        // randomize the fish state
        var colors = Enum.GetValues(typeof(FishColor));
        Color = (FishColor)(colors.GetValue(_random.Next(colors.Length)) ?? FishColor.Orange);
        var scaleValue = _random.NextDouble() * (1.00 - 0.5) + 0.5;
        Scale = scaleValue.ToString("0.##");

        var direction = _random.Next(0, 2) == 0 ? -1 : 1;
        FishVelocity = new Velocity((_random.NextDouble() * 3.0 + 0.5) * direction, (_random.NextDouble() - 0.5) * 0.5);

        _animationTimer.Elapsed += async (sender, e) => await MoveFishAsync();
    }

    private async Task MoveFishAsync()
    {
        var tankRect = await JSRuntime.InvokeAsync<ClientRect>("getTankRect");
        var fishRect = await JSRuntime.InvokeAsync<ClientRect>("getElementRect", fishElement);

        var currentPostion = new Point(fishRect.Left, fishRect.Top);
        var nextPosition = currentPostion + FishVelocity;

        if (nextPosition.Top <= tankRect.Top)
        {
            FishVelocity.dy = Math.Abs(FishVelocity.dy);
        }
        else if (nextPosition.Top + HEIGHT >= tankRect.Bottom)
        {
            FishVelocity.dy = -Math.Abs(FishVelocity.dy);
        }

        if (nextPosition.Left <= tankRect.Left)
        {
            FishVelocity.dx = Math.Abs(FishVelocity.dx);
        }
        else if (nextPosition.Left + WIDTH >= tankRect.Right)
        {
            FishVelocity.dx = -Math.Abs(FishVelocity.dx);
        }

        // Update the position with the potentially modified velocity
        Position = Position + FishVelocity;

        await InvokeAsync(StateHasChanged); // Ensure component re-renders on UI thread
    }

    public void Dispose() => _animationTimer?.Dispose();
}
