@implements IDisposable
@using System.Timers
@using Microsoft.JSInterop
@using System.Diagnostics
@using Fishzor.Client.Components
@using global::Fishzor.Client.Components
@inject IJSRuntime JSRuntime

<div @ref="fishElement"
     style="@($"position: absolute; left: {Position.Left}px; top: {Position.Top}px; transform: scale({Scale});")">
    <img src="@FishImagePath" alt="@Color" />
</div>
<script>
    function makeDraggable(element, dotNetRef) {
        let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;

        element.onmousedown = function dragMouseDown(e) {
            dotNetRef.invokeMethodAsync('OnDraggingStart')
            e = e || window.event;
            e.preventDefault();
            // get the mouse cursor position at startup:
            pos3 = e.clientX;
            pos4 = e.clientY;
            document.onmouseup = closeDragElement;
            // call a function whenever the cursor moves:
            document.onmousemove = elementDrag;
        }

        function elementDrag(e) {
            e = e || window.event;
            e.preventDefault();
            // calculate the new cursor position:
            pos1 = pos3 - e.clientX;
            pos2 = pos4 - e.clientY;
            pos3 = e.clientX;
            pos4 = e.clientY;
            // set the element's new position:
            element.style.top = (element.offsetTop - pos2) + "px";
            element.style.left = (element.offsetLeft - pos1) + "px";
        }

        function closeDragElement() {
            /* stop moving when mouse button is released:*/
            document.onmouseup = null;
            document.onmousemove = null;

            // let the c# know the new position
            dotNetRef.invokeMethodAsync('OnDraggingComplete', parseInt(element.style.left, 10), parseInt(element.style.top, 10));
        }
    }
</script>

@code {
    public FishColor Color { get; set; } = FishColor.Orange;
    public string Scale { get; set; } = "100.0";
    public string FrameDuration { get; set; } = "100"; // used to find the correct file name
    public Direction Direction => FishVelocity.dx > 0 ? Direction.Right : Direction.Left;
    public string FishImagePath => $"fish/{Color}/{Direction}-{FrameDuration}.png";

    private ElementReference fishElement;
    private readonly Timer _animationTimer = new(50);
    private Point Position = new();
    private Velocity FishVelocity = new();

    private static readonly Random _random = new Random();

    // the size of the fish image
    private const int HEIGHT = 84;
    private const int WIDTH = 144;

    [JSInvokable]
    public async Task OnDraggingStart()
    {
        _animationTimer.Enabled = false;
        await Task.CompletedTask;
    }


    [JSInvokable]
    public async Task OnDraggingComplete(double left, double top)
    {
        Position = new Point(left, top);
        NewVelocity();
        _animationTimer.Enabled = true;
        await Task.CompletedTask;
    }

    private void NewVelocity()
    {
        // choose a new velocity and change direction
        var direction = FishVelocity.dx > 0 ? -1 : 1;
        FishVelocity = new Velocity((_random.NextDouble() * 3.0 + 0.5) * direction, (_random.NextDouble() - 0.5) * 0.5);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // place the new fish at a random point within the tank
            var tankRect = await JSRuntime.InvokeAsync<ClientRect>("getTankRect");
            var left = (tankRect.Width - 100.0) * _random.NextDouble();
            var top = (tankRect.Height - 100.0) * _random.NextDouble();

            Position = new Point(left, top);
            await InvokeAsync(StateHasChanged); // Ensure component re-renders on UI thread

            var dotNetRef = DotNetObjectReference.Create(this);
            await JSRuntime.InvokeVoidAsync("makeDraggable", fishElement, dotNetRef);

            // now turn on the timer that drives the animation
            _animationTimer.AutoReset = true;
            _animationTimer.Enabled = true;
        }
    }

    protected override void OnInitialized()
    {
        // randomize the fish state
        var colors = Enum.GetValues(typeof(FishColor));
        Color = (FishColor)(colors.GetValue(_random.Next(colors.Length)) ?? FishColor.Orange);
        var scaleValue = _random.NextDouble() * (1.00 - 0.5) + 0.5;
        Scale = scaleValue.ToString("0.##");

        var direction = _random.Next(0, 2) == 0 ? -1 : 1;
        FishVelocity = new Velocity((_random.NextDouble() * 3.0 + 0.5) * direction, (_random.NextDouble() - 0.5) * 0.5);

        _animationTimer.Elapsed += async (sender, e) => await MoveFishAsync();
    }

    private async Task MoveFishAsync()
    {
        var tankRect = await JSRuntime.InvokeAsync<ClientRect>("getTankRect");
        // random chance to change direction and speed
        if (_random.Next(0, 400) < 1) 
        {
            NewVelocity();
        }
        else
        {
            var fishRect = await JSRuntime.InvokeAsync<ClientRect>("getElementRect", fishElement);

            var currentPostion = new Point(fishRect.Left, fishRect.Top);
            var nextPosition = currentPostion + FishVelocity;

            if (nextPosition.Top <= tankRect.Top)
            {
                FishVelocity.dy = Math.Abs(FishVelocity.dy);
            }
            else if (nextPosition.Top + HEIGHT >= tankRect.Bottom)
            {
                FishVelocity.dy = -Math.Abs(FishVelocity.dy);
            }

            if (nextPosition.Left <= tankRect.Left)
            {
                FishVelocity.dx = Math.Abs(FishVelocity.dx);
            }
            else if (nextPosition.Left + WIDTH >= tankRect.Right)
            {
                FishVelocity.dx = -Math.Abs(FishVelocity.dx);
            }

            // Update the position with the potentially modified velocity
            Position = Position + FishVelocity;

        }

        await InvokeAsync(StateHasChanged); // Ensure component re-renders on UI thread
    }

    public void Dispose() => _animationTimer?.Dispose();
}
