@implements IDisposable
@using System.Timers
@using Microsoft.JSInterop
@using Fishzor.Client.Components
@using Fishzor.Client.Services
@inject IJSRuntime JSRuntime
@inject Animator Animator

<img src="@FishImagePath" alt="@($"{Color} fish")" @ref="fishElement"
    aria-label="@($"{Color} fish {(IsClientFish ? "- your fish" : "")}")"
    style="@($"position: absolute; left: {_fishAnimation.Position.Left}px; top: {_fishAnimation.Position.Top}px; transform: scale({Scale}); {(IsClientFish ? "filter: drop-shadow(0 0 10px gold); cursor: move;" : "")}")" />

<MessageBubble Message="CurrentMessage" IsVisible="IsMessageVisible" Position="@GetBubblePosition()"
    FishDirection="@_fishAnimation.Velocity.Direction" />

<script>
    function makeDraggable(element, dotNetRef) {
        let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;

        element.onmousedown = function dragMouseDown(e) {
            dotNetRef.invokeMethodAsync('OnDraggingStart')
            e = e || window.event;
            e.preventDefault();

            // get the mouse cursor position at startup:
            pos3 = e.clientX;
            pos4 = e.clientY;

            // drag functions
            document.onmouseup = closeDragElement;
            document.onmousemove = elementDrag;
        }

        function elementDrag(e) {
            e = e || window.event;
            e.preventDefault();
            // calculate the new cursor position:
            pos1 = pos3 - e.clientX;
            pos2 = pos4 - e.clientY;
            pos3 = e.clientX;
            pos4 = e.clientY;

            // set the element's new position:
            element.style.top = (element.offsetTop - pos2) + "px";
            element.style.left = (element.offsetLeft - pos1) + "px";
        }

        function closeDragElement() {
            // disable drag functions when mouse button is released
            document.onmouseup = null;
            document.onmousemove = null;

            // let the c# know the new position
            dotNetRef.invokeMethodAsync('OnDraggingComplete', parseInt(element.style.left, 10), parseInt(element.style.top, 10));
        }
    }
</script>

@code {
    [Parameter]
    public FishColor Color { get; set; }

    [Parameter]
    public bool IsClientFish { get; set; }

    [Parameter]
    public string Scale { get; set; } = "100.0";

    [Parameter]
    public ChatMessage CurrentMessage { get; set; } = new();

    [Parameter]
    public bool IsMessageVisible { get; set; } = false;

    public string FrameDuration
    {
        get
        {
            if (_fishAnimation.Velocity.Dx > 3.0)
            {
                return "66";
            }
            if (_fishAnimation.Velocity.Dx > 2.25)
            {
                return "75";
            }
            return "100";
        }
    }

    public string FishImagePath => $"fish/{Color}/{_fishAnimation.Velocity.Direction}-{FrameDuration}.png";

    private DotNetObjectReference<Fish>? _dotNetRef;
    private ElementReference fishElement;
    private readonly FishAnimation _fishAnimation = new();
    private static readonly Random _random = new Random();

    [JSInvokable]
    public async Task OnDraggingStart()
    {
        if (IsClientFish)
        {
            _fishAnimation.Enabled = false;
            await Task.CompletedTask;
        }
    }

    [JSInvokable]
    public async Task OnDraggingComplete(double left, double top)
    {
        if (IsClientFish)
        {
            _fishAnimation.MoveFish(new Point(left, top));
            _fishAnimation.Enabled = true;
            await Task.CompletedTask;
        }
    }

    public string GetBubblePosition()
    {
        var leftPosition = _fishAnimation.Velocity.Direction == Direction.Right
        ? _fishAnimation.Position.Left + _fishAnimation.Size.Width
        : _fishAnimation.Position.Left - _fishAnimation.Size.Width / 10;
        return $"left: {leftPosition}px; top: {_fishAnimation.Position.Top - _fishAnimation.Size.Height / 1.55}px;";
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // place the new fish at a random point within the tank
            var tankRect = await JSRuntime.InvokeAsync<ClientRect>("getTankRect");
            // the 50 is buffer to keep the fish from being placed too close to the edge
            var left = (tankRect.Width - 50.0) * _random.NextDouble();
            var top = (tankRect.Height - 50.0) * _random.NextDouble();

            _fishAnimation.MoveFish(new Point(left, top));

            if (IsClientFish)
            {
                _dotNetRef = DotNetObjectReference.Create(this);
                await JSRuntime.InvokeVoidAsync("makeDraggable", fishElement, _dotNetRef);
            }
        }
    }

    protected override void OnInitialized() => Animator.OnAnimationTick += OnTimerElapsedAsync;

    // we need this as a member instead of a lambda to avoid a memory leak when the timer is disposed
    private async void OnTimerElapsedAsync() => await MoveFishAsync();

    private async Task MoveFishAsync()
    {
        if (_fishAnimation.Enabled)
        {
            // randomly change direction and/or speed
            var changeDirection = _random.Next(0, 400) < 1;
            var changeSpeed = _random.Next(0, 300) < 1;
            var newDirectionVelocity = changeDirection ? _fishAnimation.Velocity.OtherDirection() : _fishAnimation.Velocity;

            // always change speed if direction changed
            var mewVelocity = changeSpeed || changeDirection ? FishAnimation.GetRandomVelocity(newDirectionVelocity.Direction) :
            newDirectionVelocity; 

            var tankRect = await JSRuntime.InvokeAsync<ClientRect>("getTankRect");
            var fishRect = await JSRuntime.InvokeAsync<ClientRect>("getElementRect", fishElement);

            _fishAnimation.IncrementPosition(mewVelocity, tankRect, fishRect);

            await InvokeAsync(StateHasChanged); // Ensure component re-renders on UI thread
        }
    }

    public void Dispose()
    {
        _fishAnimation.Enabled = false;
        Animator.OnAnimationTick -= OnTimerElapsedAsync;
        _dotNetRef?.Dispose();
    }
}
