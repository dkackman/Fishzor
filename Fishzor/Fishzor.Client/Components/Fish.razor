@implements IDisposable
@using System.Timers
@using Microsoft.JSInterop
@using Fishzor.Client.Components
@using Ganss.Xss
@inject IJSRuntime JSRuntime
@inject HtmlSanitizer Sanitizer

<img src="@FishImagePath" alt="@($"{Color} fish")" @ref="fishElement"
    aria-label="@($"{Color} fish {(IsClientFish ? "- your fish" : "")}")"
    style="@($"position: absolute; left: {_fishAnimation.Position.Left}px; top: {_fishAnimation.Position.Top}px; transform: scale({Scale}); {(IsClientFish ? "filter: drop-shadow(0 0 10px gold); cursor: move;" : "")}")" />

<div class="message-bubble @(IsMessageVisible ? "visible" : "hidden") @CurrentMessage.Modifier"
    style="@GetBubblePosition()" role="status" aria-live="polite">
    @((MarkupString)Sanitizer.Sanitize(CurrentMessage.Message))
</div>

<style>
    .message-bubble {
        position: absolute;
        top: 50%;
        transform: translate(-50%, -50%);
        background-color: rgba(255, 255, 255, 0.4);
        border: 2px solid rgba(255, 255, 255, 0.6);
        border-radius: 50%;
        padding: 10px;
        max-width: 150px;
        word-wrap: break-word;
        transition: opacity 0.5s ease-in-out;
        box-shadow: 0 0 10px rgba(255, 255, 255, 0.3), inset 0 0 20px rgba(255, 255, 255, 0.3);
        backdrop-filter: blur(2px);
        animation: float 4s infinite ease-in-out;
    }

    .message-bubble::before,
    .message-bubble::after {
        content: '';
        position: absolute;
        background-color: rgba(255, 255, 255, 0.4);
        border: 1px solid rgba(255, 255, 255, 0.6);
        border-radius: 50%;
    }

    .message-bubble::before {
        width: 15px;
        height: 15px;
        bottom: -20px;
        left: 20%;
        animation: float 3s infinite ease-in-out 0.5s;
    }

    .message-bubble::after {
        width: 10px;
        height: 10px;
        bottom: -35px;
        left: 40%;
        animation: float 3s infinite ease-in-out 1s;
    }

    @@keyframes float {

        0%,
        100% {
            transform: translate(-50%, -50%);
        }

        50% {
            transform: translate(-50%, -60%);
        }
    }

    .message-bubble.hidden {
        opacity: 0;
    }

    .message-bubble.visible {
        opacity: 1;
    }

    .message-bubble.shout {
        font-weight: bold;
        text-transform: uppercase;
        font-size: larger;
        color: #FF0000;
    }

    .message-bubble.whisper {
        font-weight: italic;
        text-transform: lowercase;
        font-size: smaller;
        color: #60666e;
    }

    // Add more modifier styles as needed
</style>
<script>
    function makeDraggable(element, dotNetRef) {
        let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;

        element.onmousedown = function dragMouseDown(e) {
            dotNetRef.invokeMethodAsync('OnDraggingStart')
            e = e || window.event;
            e.preventDefault();

            // get the mouse cursor position at startup:
            pos3 = e.clientX;
            pos4 = e.clientY;

            // drag functions
            document.onmouseup = closeDragElement;
            document.onmousemove = elementDrag;
        }

        function elementDrag(e) {
            e = e || window.event;
            e.preventDefault();
            // calculate the new cursor position:
            pos1 = pos3 - e.clientX;
            pos2 = pos4 - e.clientY;
            pos3 = e.clientX;
            pos4 = e.clientY;

            // set the element's new position:
            element.style.top = (element.offsetTop - pos2) + "px";
            element.style.left = (element.offsetLeft - pos1) + "px";
        }

        function closeDragElement() {
            // disable drag functions when mouse button is released
            document.onmouseup = null;
            document.onmousemove = null;

            // let the c# know the new position
            dotNetRef.invokeMethodAsync('OnDraggingComplete', parseInt(element.style.left, 10), parseInt(element.style.top, 10));
        }
    }
</script>

@code {
    [Parameter]
    public FishColor Color { get; set; }

    [Parameter]
    public bool IsClientFish { get; set; }

    [Parameter]
    public string Scale { get; set; } = "100.0";

    [Parameter]
    public ChatMessage CurrentMessage { get; set; } = new();

    [Parameter]
    public bool IsMessageVisible { get; set; } = false;

    public string FrameDuration
    {
        get
        {
            if (_fishAnimation.Velocity.Dx > 3.0)
            {
                return "66";
            }
            if (_fishAnimation.Velocity.Dx > 2.25)
            {
                return "75";
            }
            return "100";
        }
    }

    public string FishImagePath => $"fish/{Color}/{_fishAnimation.Velocity.Direction}-{FrameDuration}.png";

    private DotNetObjectReference<Fish>? _dotNetRef;
    private ElementReference fishElement;
    private readonly FishAnimation _fishAnimation = new();

    // a single timer drives the animation for all fish
    private static readonly Timer _animationTimer = new(50) { AutoReset = true, Enabled = false };
    private static readonly Random _random = new Random();

    private const int BUBBLE_OFFSET = 72;

    [JSInvokable]
    public async Task OnDraggingStart()
    {
        if (IsClientFish)
        {
            _fishAnimation.Enabled = false;
            await Task.CompletedTask;
        }
    }

    [JSInvokable]
    public async Task OnDraggingComplete(double left, double top)
    {
        if (IsClientFish)
        {
            _fishAnimation.MoveFish(new Point(left, top));
            _fishAnimation.Enabled = true;
            await Task.CompletedTask;
        }
    }

    public string GetBubblePosition()
    {
        var leftPosition = _fishAnimation.Velocity.Direction == Direction.Right
        ? _fishAnimation.Position.Left + BUBBLE_OFFSET
        : _fishAnimation.Position.Left;// - BUBBLE_OFFSET / 2;
        return $"left: {leftPosition}px; top: {_fishAnimation.Position.Top - 20}px;";
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // place the new fish at a random point within the tank
            var tankRect = await JSRuntime.InvokeAsync<ClientRect>("getTankRect");
            // the 50 is buffer to keep the fish from being placed too close to the edge
            var left = (tankRect.Width - 50.0) * _random.NextDouble();
            var top = (tankRect.Height - 50.0) * _random.NextDouble();

            _fishAnimation.MoveFish(new Point(left, top));
            await InvokeAsync(StateHasChanged); // Ensure component re-renders on UI thread

            if (IsClientFish)
            {
                _dotNetRef = DotNetObjectReference.Create(this);
                await JSRuntime.InvokeVoidAsync("makeDraggable", fishElement, _dotNetRef);
            }

            // now turn on the static timer that drives the animation
            // if it's not already running
            if (!_animationTimer.Enabled)
            {
                _animationTimer.Enabled = true;
            }
        }
    }

    protected override void OnInitialized()
    {
        _animationTimer.Elapsed += OnTimerElapsedAsync;
    }

    // we need this as a member instead of a lambda to avoid a memory leak when the timer is disposed
    private async void OnTimerElapsedAsync(object? sender, ElapsedEventArgs e) => await MoveFishAsync();

    private async Task MoveFishAsync()
    {
        if (_fishAnimation.Enabled)
        {
            // randomly change direction and/or speed
            var changeDirection = _random.Next(0, 400) < 1;
            var changeSpeed = _random.Next(0, 300) < 1;
            var newDirectionVelocity = changeDirection ? _fishAnimation.Velocity.OtherDirection() : _fishAnimation.Velocity;

            // always change speed if direction changed
            var mewVelocity = changeSpeed || changeDirection ? FishAnimation.GetRandomVelocity(newDirectionVelocity.Direction) :
            newDirectionVelocity;

            var tankRect = await JSRuntime.InvokeAsync<ClientRect>("getTankRect");
            var fishRect = await JSRuntime.InvokeAsync<ClientRect>("getElementRect", fishElement);

            _fishAnimation.IncrementPosition(mewVelocity, tankRect, fishRect);

            await InvokeAsync(StateHasChanged); // Ensure component re-renders on UI thread
        }
    }

    public void Dispose()
    {
        _fishAnimation.Enabled = false;
        _animationTimer.Elapsed -= OnTimerElapsedAsync;
        _dotNetRef?.Dispose();
    }
}
